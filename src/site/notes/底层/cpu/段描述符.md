---
{"dg-publish":true,"permalink":"/底层/cpu/段描述符/","noteIcon":"1","created":"","updated":""}
---



## 32 位段寄存器结构
段寄存器在 CPU 中一共 96 位，如图所示：
![段寄存器结构图.png|段寄存器结构图](/img/user/%E5%9B%BE%E7%89%87/%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%93%E6%9E%84%E5%9B%BE.png)
 如果用代码来描述的话：
```cpp
struct Segment {
  WORD Selector; // 16位段选择子
  WORD Attributes; //16位属性
  DWORD Base; //32位段地址
  DWORD Limit; //32位偏移地址
};
```
 
 在 32 位保护模式中，段寄存器的可见部分称为**段选择子**，由以下 3 部分组成：
- **RPL** 请求特权级别，数越小，权限越大。RPL 是 3，只能访问 3 的描述符。
- **TI** 表指示位，如果 TI 位为 0，则查 GDT 表，如果 TI 位为 1，则查 LDT 表。
- **Index** 在 GDT 或 LDT 中的索引值。
![../../图片/段选择子.png|段选择子](/img/user/%E5%9B%BE%E7%89%87/%E6%AE%B5%E9%80%89%E6%8B%A9%E5%AD%90.png)

处理器将内存划分成逻辑上的段，并在指令中使用段内偏移地址，在保护模式下，对内存的访问仍然使用段地址和偏移地址，但是，在每个段能够访问之前，必须先进行登记。
当程序访问的偏移地址超出段的界限时，处理器就会阻止这种访问，并产生一个叫做内部异常的中断。

一个段有关的信息需要 8 个字节来描述，所以称为段描述符。
8 个字节，8 个字节的描述符连在一起的段空间叫做**描述符表**。

![../../图片/段描述符1.png](/img/user/%E5%9B%BE%E7%89%87/%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A61.png)

- G 位是粒度（Granularity）位，用于解释段界限的含义。
  当 G 位是“0”时，段界限以字节为单位。此时，段的扩展范围是从 1 字节到 1 兆字节（1B～1MB），因为描述符中的界限值是20 位的。相反，如果 G 位是“1”，那么，段界限是以 4KB 为单位的。这样，段的扩展范围是从4KB 到 4GB。
  1. G=0时，最多扩展2^20个字节，2^20 = 1048576B / 1024 = 1024KB / 1024 = 1MB
  2. G=1时，最多扩展2^20 * 4096 = 1 MB * 4096 = 4 G
- D/B 位是“默认操作尺寸”(Default Operation Size)或者“默认的栈指针尺寸”(Default Stack Pointer Size)，又或者“上部边界”(Upper Bound)标志。
  - 对于代码段，此位称作“D”位，用于指示指令中默认的有效地址和操作数尺寸。D=0表示指令中的有效地址或者操作数是16位的；D=1，指示32位的有效地址或者操作数。
  - 对于栈段和向下扩展的数据段来说，该位被叫作“B”位，用于指定在进行隐式的栈操作时，是使用寄存器 SP 还是寄存器 ESP。如果B位是0，段的下部边界由段界限确定，段的上部边界是0xFFFF；如果B位是1，段的下部边界由段界限确定，段的上部边界是0xFFFFFFFF。
- L：表示 64 位的代码段。=1 是 64 位模式，=0 是兼容模式代码。
- AVL：保留没用，供操作系统使用。
- P 是段存在位 (Segment Present)。P 位用于指示描述符所对应的段是否存在。
- DPL 表示描述符的特权级 (Descriptor Privilege Level, DPL)。共有4种处理器支持的特权级别，分别是0、1、2、3，其中0是最高特权级别，3是最低特权级别。
- S 位：在第 44 位 
  - S = 0，系统描述符，TYPE 字段用来指定系统段的类型或者门的类型。
  - S = 1，存储器的段描述符，TYPE 字段用来区分代码段和数据段。
- TYPE 字段共4位，当 S = 1 时，用于指示非系统描述符的子类型，或者说是类别。
  - 对于数据段来说，这4位分别是 X、E、W、A 位；
  - 对于代码段来说，这4位则分别是 X、C、R、A 位。
  ![x86 保护模式架构.png|描述符类别](/img/user/%E5%9B%BE%E7%89%87/x86%20%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E6%9E%B6%E6%9E%84.png)
    ![x86 保护模式架构-1.png](/img/user/%E5%9B%BE%E7%89%87/x86%20%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E6%9E%B6%E6%9E%84-1.png)
    对于代码段来说，C 位指示段是否为特权级依从的（**一致代码段**）。
  - C=0 表示非依从的代码段（非一致代码段），这样的代码段可以从与它特权级相同的代码段调用，或者通过门调用；
  - C=1 表示一致代码段，允许从低特权级的程序转移到该段执行。（3 环执行 0 环代码）
  数据段和代码段的A位是已访问(Accessed)位，用于指示它所指向的段最近是否被访问过。在描述符创建的时候，应该清零。之后，每当该段被访问时，处理器自动将该位置“1”。

  当 S 位为 0 时，Type 指示系统段的类型：
  ![../../图片/1-段描述符.png|系统段类型](/img/user/%E5%9B%BE%E7%89%87/1-%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6.png)

## 描述符表
1. 全局描述符表（Global Descriptor Table，GDT），所谓全局，意味着该表是为整个软硬件系统服务的。在进入保护模式前，必须要定义全局描述符表。
2. 本地描述符表，每个任务都有一个，Windows 系统不使用。

![../../图片/2-段描述符.png](/img/user/%E5%9B%BE%E7%89%87/2-%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6.png)

为了跟踪全局描述符表，处理器内部有一个48 位的寄存器，称为全局描述符表寄存器（GDTR）。该寄存器分为两部分，分别是32 位的线性地址和16 位的边界。32 位的处理器具有32 根地址线，可以访问的地址范围是0x00000000 到0xFFFFFFFF，共 2^32 字节的内存，即 4GB 内存。

因为GDT 的界限是16 位的，所以，该表最大是2^16 字节，也就是65536 字节（64KB）。又因为一个描述符占8 字节，故最多可以定义8192 个描述符。

## 地址转换
逻辑地址到线性地址的转换：根据段选择子的 index，去查表，如果 TI 位为 0，则查 GDT 表，如果是 1，则查 LDT 表。由于全局描述符表第一个无效，因此：`查找的GDT描述符地址=(index+1) * 8`
![../../图片/逻辑地址到线性地址的转换.png|逻辑地址到线性地址的转换](/img/user/%E5%9B%BE%E7%89%87/%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E5%88%B0%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80%E7%9A%84%E8%BD%AC%E6%8D%A2.png)